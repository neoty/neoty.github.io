<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>섥</title>
  
  <subtitle>Life on earth</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.seq.kr/"/>
  <updated>2018-11-25T11:33:34.000Z</updated>
  <id>https://blog.seq.kr/</id>
  
  <author>
    <name>seq.kr</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nginx server header 감추기</title>
    <link href="https://blog.seq.kr/2018/11/25/linux/nginx-hide-server-header/"/>
    <id>https://blog.seq.kr/2018/11/25/linux/nginx-hide-server-header/</id>
    <published>2018-11-25T09:23:00.000Z</published>
    <updated>2018-11-25T11:33:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>nginx 기본 설치 시 후 response 응답의 header를 보면 <code>server</code> 항목에 nginx 버전과 심지어 os 정보까지 출력된다.<br>보안적인 측면에서 당연히 좋을 리가 없다. (해당 정보들을 수집하여 자동으로 웹서버 통계를 만드는 것으로 보이는데 통계를 위해 서비스를 하는 건 아니니..)</p><p><strong><em>ubuntu 16.04 에서 작성되었습니다.</em></strong></p><h3 id="nginx-버전과-os-정보-감추기"><a href="#nginx-버전과-os-정보-감추기" class="headerlink" title="nginx 버전과 os 정보 감추기"></a>nginx 버전과 os 정보 감추기</h3><h4 id="nginx-conf-설정"><a href="#nginx-conf-설정" class="headerlink" title="nginx.conf 설정"></a>nginx.conf 설정</h4><div class="note simple info"><p><strong>Syntax</strong>: server_tokens on | off | build | string;<br><strong>Default</strong>: server_tokens on;<br><strong>Context</strong>: http, server, location</p></div><p>http, server, location context에 적용 가능하다. 특별한일이 없다면 http context에 적용<br><figure class="highlight shell"><figcaption><span>nginx.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server_tokens off;</span><br><span class="line">    생략</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><figcaption><span>nginx 재시작</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo nginx -t</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo service nginx reload</span></span><br></pre></td></tr></table></figure><h3 id="response-server-header-삭제"><a href="#response-server-header-삭제" class="headerlink" title="response server header 삭제"></a>response server header 삭제</h3><h4 id="nginx-extras-패키지-설치"><a href="#nginx-extras-패키지-설치" class="headerlink" title="nginx-extras 패키지 설치"></a>nginx-extras 패키지 설치</h4><p>위 단계는 nginx 버전 정보와 서버 os까지는 유효하지만 웹 서버 정보(nginx) 를 감추진 못한다. 구글링 결과 컴파일 단계에서 수정하는 방법 등이 존재하지만. 좀 더 쉬운 방법을 적용하였다. nginx-extras 패키지를 설치하는 방법이다.<br><strong>(처음부터 nginx-extras를 설치하면 된다)</strong><br><figure class="highlight shell"><figcaption><span>패키지 설치 후 재시작</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install nginx-extras</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo nginx -t</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo service nginx reload</span></span><br></pre></td></tr></table></figure></p><div class="note simple danger"><p>nginx-extras는 다양한 모듈을 더 지원하지만 성능이나 기능에 버그가 포함되어 있을 수도 있습니다. (사용에 신중을 기하세요.)</p></div><h4 id="nginx-conf-설정-1"><a href="#nginx-conf-설정-1" class="headerlink" title="nginx.conf 설정"></a>nginx.conf 설정</h4><div class="note simple info"><p><strong>syntax</strong>: more_set_headers [-t <code>&lt;content-type list&gt;</code>]… [-s <code>&lt;status-code list&gt;</code>]… <code>&lt;new-header&gt;</code>…<br><strong>default</strong>: no<br><strong>context</strong>: http, server, location, location if<br><strong>phase</strong>: output-header-filter</p></div><p>overwrite 방법으로 내용을 삭제한다.<br><figure class="highlight shell"><figcaption><span>nginx.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    more_set_headers 'Server: ';</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><figcaption><span>nginx 재시작</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo nginx -t</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo service nginx reload</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nginx 기본 설치 시 후 response 응답의 header를 보면 &lt;code&gt;server&lt;/code&gt; 항목에 nginx 버전과 심지어 os 정보까지 출력된다.&lt;br&gt;보안적인 측면에서 당연히 좋을 리가 없다. (해당 정보들을 수집하여 자동으로
      
    
    </summary>
    
      <category term="Linux" scheme="https://blog.seq.kr/categories/Linux/"/>
    
    
      <category term="linux" scheme="https://blog.seq.kr/tags/linux/"/>
    
      <category term="nginx" scheme="https://blog.seq.kr/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>pm2 graceful start</title>
    <link href="https://blog.seq.kr/2018/11/25/nodejs/pm2-graceful-start/"/>
    <id>https://blog.seq.kr/2018/11/25/nodejs/pm2-graceful-start/</id>
    <published>2018-11-25T05:20:11.000Z</published>
    <updated>2018-11-26T12:39:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="graceful-start"><a href="#graceful-start" class="headerlink" title="graceful start"></a>graceful start</h3><div class="note info"><p>Sometimes you might need to wait for your application to have etablished connections with your DBs/caches/workers/whatever. PM2 needs to wait before considering your application as online. To do this, you need to provide –wait-ready to the CLI or provide wait_ready: true in a process file. This will make PM2 listen for that event. In your application you will need to add process.send(‘ready’); when you want your application to be considered as ready.</p><p><strong><em><a href="http://pm2.keymetrics.io/docs/usage/signals-clean-restart/#graceful-start" target="_blank" rel="noopener">pm2 graceful start</a></em></strong></p></div><p>node application 구동시 일련의 과정을 거치기 마련이다 (db, memory db pool 생성이나 기타 비동기적인 initialization 작업등) 동기 작업이라면 상관없겠지만 비동기 작업 같은 경우 콜백 등으로 구현해서 모든게 준비가 되었을떄 application 을 구동(사용 단계로 격상) 시켜야 한다.<br>pm2는 이러한 상황에 대비에 옵션으로 해당 과정을 쉽게 할 수 있게 기능을 제공한다.</p><p><strong>(원문에선 cli로 옵션을 줄수도 있지만 여기에선 ecosystem.config.js를 기준으로 설명)</strong></p><h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><h4 id="graceful-start-활성화"><a href="#graceful-start-활성화" class="headerlink" title="graceful start 활성화"></a>graceful start 활성화</h4><figure class="highlight javascript"><figcaption><span>ecosystem.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  apps : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"name"</span>            : <span class="string">'pm2-graceful-start-exmaple'</span>,</span><br><span class="line">      <span class="string">"script"</span>          : <span class="string">'bin/www'</span>,</span><br><span class="line">      <span class="string">"wait_ready"</span>      : <span class="literal">true</span>,</span><br><span class="line">      <span class="string">"listen_timeout"</span>  : <span class="number">5000</span>,             <span class="comment">// ms 단위</span></span><br><span class="line">      env_production : &#123;</span><br><span class="line">        NODE_ENV: <span class="string">'production'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>핵심 옵션은 <code>wait_ready</code>와 <code>listen_timeout</code>이다. <code>wait_ready</code>값이 true라면 <code>listen_timeout</code>동안 대기하며 해당 시간 동안 특정한 signal 을 받지 못하면 강제로 application 이 시작(노출) 되게 된다.<br>(<code>listen_timeout</code>의 default값은 3000ms)</p><h4 id="application-시작-signal-보내기"><a href="#application-시작-signal-보내기" class="headerlink" title="application 시작 signal 보내기"></a>application 시작 signal 보내기</h4><figure class="highlight javascript"><figcaption><span>app.js (express template 이기 때문에 기본 코드 생략)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">생략</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  process.send(<span class="string">'ready'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"application published!"</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = app;</span><br></pre></td></tr></table></figure><p>application 이 준비가 되었을 때 <code>process.send(&#39;ready&#39;)</code>코드로 pm2에 signal 을 보내면 된다. (예제는 2초 후에 앱이 구동) 비동기적인 작업등을 명시하고 모든 비동기 작업이 끝나면 콜백으로 <code>process.send(&#39;ready&#39;)</code>실행하여 안정적인 application 구동을 꾀할 수 있다.</p><h4 id="Sample-source-download"><a href="#Sample-source-download" class="headerlink" title="Sample source download"></a>Sample source download</h4><a class="btn" href="https://github.com/neoty/example-pm2-ready" target="_blank" rel="noopener"><i class="fa fa-fab fa-fw fa-github fa-lg"></i>example-pm2-ready</a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;graceful-start&quot;&gt;&lt;a href=&quot;#graceful-start&quot; class=&quot;headerlink&quot; title=&quot;graceful start&quot;&gt;&lt;/a&gt;graceful start&lt;/h3&gt;&lt;div class=&quot;note info&quot;&gt;&lt;p
      
    
    </summary>
    
      <category term="Nodejs" scheme="https://blog.seq.kr/categories/Nodejs/"/>
    
    
      <category term="nodejs" scheme="https://blog.seq.kr/tags/nodejs/"/>
    
      <category term="pm2" scheme="https://blog.seq.kr/tags/pm2/"/>
    
  </entry>
  
  <entry>
    <title>express babel 적용하기</title>
    <link href="https://blog.seq.kr/2018/11/21/nodejs/start-express-babel/"/>
    <id>https://blog.seq.kr/2018/11/21/nodejs/start-express-babel/</id>
    <published>2018-11-21T12:48:41.000Z</published>
    <updated>2018-11-26T12:30:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel?"></a>Babel?</h3><div class="note info"><p>Babel is a toolchain that is mainly used to convert ECMAScript 2015+ code into a backwards compatible version of JavaScript in current and older browsers or environments. Here are the main things Babel can do for you<br><strong><em><a href="https://babeljs.io/docs/en/" target="_blank" rel="noopener">babeljs.io</a></em></strong></p></div><p><code>babel</code>은 최신 ECMA 문법을 하위 버전에 맞게 변환하여 최신 ECMA 문법을 사용할 수 있는 장점과 최신 ECMA 문법에 구애받지 않고 코드를 실행할 수 있게 해주는 도구이다.</p><h3 id="express-와-babel-사용하기"><a href="#express-와-babel-사용하기" class="headerlink" title="express 와 babel 사용하기"></a>express 와 babel 사용하기</h3><h4 id="sample-폴더-만들기"><a href="#sample-폴더-만들기" class="headerlink" title="sample 폴더 만들기"></a>sample 폴더 만들기</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir example-express-babel</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> example-express-babel</span></span><br></pre></td></tr></table></figure><h4 id="express-init"><a href="#express-init" class="headerlink" title="express init"></a>express init</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> express --view=ejs .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br></pre></td></tr></table></figure><h4 id="소스-위치-변경"><a href="#소스-위치-변경" class="headerlink" title="소스 위치 변경"></a>소스 위치 변경</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir src</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mv app.js bin public routes views ./src</span></span><br></pre></td></tr></table></figure><p>변환 대상이 되는 소스 폴더는 따로 <code>src</code> 폴더를 만들어서 옮긴다.</p><h4 id="babel-모듈-추가-amp-삭제-모듈-추가"><a href="#babel-모듈-추가-amp-삭제-모듈-추가" class="headerlink" title="babel 모듈 추가 &amp; 삭제 모듈 추가"></a>babel 모듈 추가 &amp; 삭제 모듈 추가</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install babel-cli --save-dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install babel-preset-env --save-dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install rimraf --save-dev</span></span><br></pre></td></tr></table></figure><h4 id="build-스크립트-추가-amp-start-command-변경"><a href="#build-스크립트-추가-amp-start-command-변경" class="headerlink" title="build 스크립트 추가 &amp; start command 변경"></a>build 스크립트 추가 &amp; start command 변경</h4><figure class="highlight bash"><figcaption><span>package.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ vi package.json</span><br><span class="line">... 생략</span><br><span class="line"></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"node ./dist/bin/www"</span>,</span><br><span class="line">    <span class="string">"prebuild"</span>: <span class="string">"rimraf ./dist"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"babel src --minified --out-dir ./dist --source-maps --copy-files"</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">... 생략</span><br></pre></td></tr></table></figure><p><code>prebuild</code>는 <code>npm run build</code> 실행 시 <code>build</code> 스크립트가 실행 전 실행되는 커맨드이다. (변환된 파일이 위치하게 될 <code>dist</code> 폴더를 깨끗이 삭제하는 작업)</p><h4 id="preset-설정"><a href="#preset-설정" class="headerlink" title="preset 설정"></a>preset 설정</h4><figure class="highlight shell"><figcaption><span>.babelrc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">    "presets": [</span><br><span class="line">        ["env", &#123;</span><br><span class="line">          "targets": &#123;</span><br><span class="line">            "node": "current"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>현재 설치된 <code>node</code> 버전에 맞게 변환 하도록 설정</p><h4 id="build-시작"><a href="#build-시작" class="headerlink" title="build 시작"></a>build 시작</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm run build</span></span><br></pre></td></tr></table></figure><p><code>build</code> 실행</p><h4 id="실행"><a href="#실행" class="headerlink" title="실행"></a>실행</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run start</span><br></pre></td></tr></table></figure><h4 id="Sample-source-download"><a href="#Sample-source-download" class="headerlink" title="Sample source download"></a>Sample source download</h4><a class="btn" href="https://github.com/neoty/example-express-babel" target="_blank" rel="noopener"><i class="fa fa-fab fa-fw fa-github fa-lg"></i>example-express-babel</a><h3 id="추가"><a href="#추가" class="headerlink" title="추가"></a>추가</h3><p>ci/cd 시나리오로는</p><ol><li>개발 완료</li><li>원격 저장소 push</li><li>hook 을 이용하여 ci 도구에서 pull</li><li>ci에서 build 후</li><li>build 결과물을 배포</li><li>서버에서 재실행</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Babel&quot;&gt;&lt;a href=&quot;#Babel&quot; class=&quot;headerlink&quot; title=&quot;Babel?&quot;&gt;&lt;/a&gt;Babel?&lt;/h3&gt;&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;Babel is a toolchain that is main
      
    
    </summary>
    
      <category term="Nodejs" scheme="https://blog.seq.kr/categories/Nodejs/"/>
    
    
      <category term="nodejs" scheme="https://blog.seq.kr/tags/nodejs/"/>
    
      <category term="babel" scheme="https://blog.seq.kr/tags/babel/"/>
    
  </entry>
  
  <entry>
    <title>dotenv 모듈을 이용하여 동적으로 enviroment 변수 정의</title>
    <link href="https://blog.seq.kr/2018/11/20/nodejs/dotenv-load-enviroment-file/"/>
    <id>https://blog.seq.kr/2018/11/20/nodejs/dotenv-load-enviroment-file/</id>
    <published>2018-11-20T12:43:21.000Z</published>
    <updated>2018-11-26T12:20:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="dotenv"><a href="#dotenv" class="headerlink" title="dotenv"></a>dotenv</h3><div class="note info"><p>Dotenv is a zero-dependency module that loads environment variables from a .env file into process.env. Storing configuration in the environment separate from code is based on The Twelve-Factor App methodology.<br><strong><em><a href="https://www.npmjs.com/package/dotenv" target="_blank" rel="noopener">npmjs dotenv</a></em></strong></p></div><p>nodejs dotenv 모듈을 이용하여 서버마다 최소한의 설정으로 환경에 맞는 환경변수를 사용한다.<br><strong><em>(환경 변수는 소스코드에 포함시키지 않는 게 정석이나… 관리 측면이나 공개할 소스는 아니기 때문에 상황에 맞게 사용하시면 될 듯..)</em></strong></p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><h4 id="실습-앱-생성"><a href="#실습-앱-생성" class="headerlink" title="실습 앱 생성"></a>실습 앱 생성</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir example-dotenv</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> example-dotenv</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm init</span></span><br><span class="line">모두 enter 입력</span><br></pre></td></tr></table></figure><h4 id="dotenv-설치"><a href="#dotenv-설치" class="headerlink" title="dotenv 설치"></a>dotenv 설치</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install dotenv</span></span><br></pre></td></tr></table></figure><h4 id="테스트용-env-파일-생성"><a href="#테스트용-env-파일-생성" class="headerlink" title="테스트용 .env 파일 생성"></a>테스트용 .env 파일 생성</h4><figure class="highlight plain"><figcaption><span>test.env</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test1=test1내용</span><br><span class="line">test2=test2내용</span><br></pre></td></tr></table></figure><h4 id="index-js-파일-생성"><a href="#index-js-파일-생성" class="headerlink" title="index.js 파일 생성"></a>index.js 파일 생성</h4><figure class="highlight javascript"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dotenv = <span class="built_in">require</span>(<span class="string">'dotenv'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'dotenv'</span>).config(&#123; <span class="attr">path</span>: <span class="string">'test.env'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(process.env.test1);</span><br><span class="line"><span class="built_in">console</span>.log(process.env.test2);</span><br></pre></td></tr></table></figure><h4 id="index-js-실행"><a href="#index-js-실행" class="headerlink" title="index.js 실행"></a>index.js 실행</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node index.js</span></span><br><span class="line">test1 내용</span><br><span class="line">test2 내용</span><br></pre></td></tr></table></figure><h4 id="Sample-source-download"><a href="#Sample-source-download" class="headerlink" title="Sample source download"></a>Sample source download</h4><a class="btn" href="https://github.com/neoty/example-dotenv" target="_blank" rel="noopener"><i class="fa fa-fab fa-fw fa-github fa-lg"></i>example-dotenv</a><h3 id="활용"><a href="#활용" class="headerlink" title="활용"></a>활용</h3><p>기본 골자는 <code>.env</code> 파일에 있는 내용을 그대로 <code>process.env</code>에서 사용할 수 있도록 해준다는건데, 서버별로 기본적으로 <code>NODE_ENV</code> 를 정의해놓고 서버 마다 다른 환경 설정을 기술하고 서버마다 환경에 맞는 <code>.env</code> 파일을 로드할 수 있게끔 할 수 있다.</p><h4 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h4><figure class="highlight javascript"><figcaption><span>app.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'dotenv'</span>).config(&#123; <span class="attr">path</span>: path.join(__dirname, <span class="string">`config/<span class="subst">$&#123;process.env.NODE_ENV || <span class="string">'development'</span>&#125;</span>.env`</span>) &#125;);</span><br></pre></td></tr></table></figure><p>기본 정의되어 있는 <code>NODE_ENV</code>가 정의되어 있으면 해당 <code>NODE_ENV</code> 값에 맞는 <code>.env</code> 파일을 <code>config</code> 폴더에서 찾는 모습이다. <code>NODE_ENV</code>가 없으면 기본 <code>development.env</code> 파일을 로드</p><h3 id="주의사항"><a href="#주의사항" class="headerlink" title="주의사항"></a>주의사항</h3><div class="note danger"><p><strong>What happens to environment variables that were already set?</strong><br>We will never modify any environment variables that have already been set. In particular, if there is a variable in your .env file which collides with one that already exists in your environment, then that variable will be skipped. This behavior allows you to override all .env configurations with a machine-specific environment, although it is not recommended.<br><strong><em><a href="https://www.npmjs.com/package/dotenv" target="_blank" rel="noopener">npmjs dotenv</a></em></strong></p></div><p><strong><code>process.env</code>아래에 이미 key가 정의되어있다면 <code>dotenv</code> 로드하여도 해당 key의 value는 overwrite 되지 않는다.(강제로 할당 하는 방법은 존재함)</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;dotenv&quot;&gt;&lt;a href=&quot;#dotenv&quot; class=&quot;headerlink&quot; title=&quot;dotenv&quot;&gt;&lt;/a&gt;dotenv&lt;/h3&gt;&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;Dotenv is a zero-dependency mod
      
    
    </summary>
    
      <category term="Nodejs" scheme="https://blog.seq.kr/categories/Nodejs/"/>
    
    
      <category term="nodejs" scheme="https://blog.seq.kr/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>mysql connection pooling</title>
    <link href="https://blog.seq.kr/2018/11/19/nodejs/nodejs-mysql-pool/"/>
    <id>https://blog.seq.kr/2018/11/19/nodejs/nodejs-mysql-pool/</id>
    <published>2018-11-19T12:43:21.000Z</published>
    <updated>2018-11-25T11:40:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="database-pooling-이-란"><a href="#database-pooling-이-란" class="headerlink" title="database pooling 이 란"></a>database pooling 이 란</h3><div class="note info"><p>In software engineering, a connection pool is a cache of database connections maintained so that the connections can be reused when future requests to the database are required. Connection pools are used to enhance the performance of executing commands on a database. (구글 <code>database pooling</code> 검색 시)</p></div><p>간단히 말해서 데이터베이스 커넥션의 캐시 개념이다 적당한 양의 pool 을 생성해놓고 application에서 database 접근이 필요할 때 connection을 처음부터 맺는 게 아니라 기존에 맺어져 있던 connection 을 하나 들고 와서 바로 사용할 수 있게 하는 개념입니다.</p><p><span style="color:#f05f70"><strong><em><a href="https://www.npmjs.com/package/mysql#pooling-connections" target="_blank" rel="noopener">mysql module pool에 대한 자세한 설명은 여기서</a></em></strong></span></p><h3 id="code-구현-기본-setup-pass"><a href="#code-구현-기본-setup-pass" class="headerlink" title="code 구현 (기본 setup pass)"></a>code 구현 (기본 setup pass)</h3><h4 id="mysql-모듈-설치"><a href="#mysql-모듈-설치" class="headerlink" title="mysql 모듈 설치"></a>mysql 모듈 설치</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install mysql</span><br></pre></td></tr></table></figure><h4 id="pool-생성"><a href="#pool-생성" class="headerlink" title="pool 생성"></a>pool 생성</h4><p>최초 1회 database에 접속하여 connection 이 정상일 경우 pool 을 생성하는 코드 pool 을 global로 할당하였지만 입맛에 맞게 수정하시면 됩니다.<br><figure class="highlight javascript"><figcaption><span>db.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mysql <span class="keyword">from</span> <span class="string">'mysql'</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 기본 정보 설정</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> connectionInfo = &#123;</span><br><span class="line">  host: process.env.DB_HOST,                            <span class="comment">// mysql 호스트</span></span><br><span class="line">  port: process.env.DB_PORT,                            <span class="comment">// mysql 포트</span></span><br><span class="line">  user: process.env.DB_USER,                            <span class="comment">// mysql access 아이디</span></span><br><span class="line">  password: process.env.DB_PASSWORD,                    <span class="comment">// mysql access 비밀번호</span></span><br><span class="line">  database: process.env.DB_DATABASE,                    <span class="comment">// 기본 접근 database 명</span></span><br><span class="line">  connectionLimit: process.env.DB_CONNECTION_LIMIT,     <span class="comment">// 최대 생성할 수 있는 pool 개수(추후 포스팅) </span></span><br><span class="line">  charset: process.env.DB_CHARSET,                      <span class="comment">// 연결 케릭터셋</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* pool 에서 실행되는 모든 쿼리들의 sql 로그를 남김</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> poolEventSetup = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  global.pool.on(<span class="string">'connection'</span>, (poolConnection) =&gt; &#123;</span><br><span class="line">    poolConnection.on(<span class="string">'enqueue'</span>, (sequence) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (sequence.constructor.name === <span class="string">'Query'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(sequence.sql);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 일반 connection 접속 체크 후 pool 생성</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> initialization = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> connectionCheck = mysql.createConnection(connectionInfo);</span><br><span class="line">  connectionCheck.connect(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    connectionCheck.end();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// connection 에러 발생</span></span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// global 할당 ex) pool.query('select * from test', (err, results) =&gt; &#123;&#125;);</span></span><br><span class="line">    global.pool = mysql.createPool(connectionInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 개발 환경 시 실행 query 로깅 활성화</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) poolEventSetup();</span><br><span class="line"></span><br><span class="line">    callback(<span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.init = initialization;</span><br></pre></td></tr></table></figure></p><h4 id="app-js-module-load"><a href="#app-js-module-load" class="headerlink" title="app.js module load"></a>app.js module load</h4><figure class="highlight javascript"><figcaption><span>불필요 코드 생략</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'db'</span>).init(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    process.exit();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'pool 생성 완료'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="pool-생성-시"><a href="#pool-생성-시" class="headerlink" title="pool 생성 시"></a>pool 생성 시</h3><p><code>connectionLimit</code> 값을 100으로 하고 앱을 구동시 pool connection 이 곧바로 100개가 생성이 되진 않습니다.<br>초기엔 최소의 pool 개수를 유지하고 실제 여유분의 pool 이 없을 시 <code>connectionLimit</code> 개수만큼 pool connection 이 생성됩니다.<br><span style="color:#f05f70"><strong><em>(동시에 실행되는 query 가 많을 시 생성)</em></strong></span></p><p>실제로 다양한 옵션이 존재하고 mysql에 connection timeout 설정도 해주어야 진정한 pool 효과를 볼 수가 있습니다 해당 부분에 대해서 추후에 포스팅으로 다루겠습니다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;database-pooling-이-란&quot;&gt;&lt;a href=&quot;#database-pooling-이-란&quot; class=&quot;headerlink&quot; title=&quot;database pooling 이 란&quot;&gt;&lt;/a&gt;database pooling 이 란&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="Nodejs" scheme="https://blog.seq.kr/categories/Nodejs/"/>
    
    
      <category term="nodejs" scheme="https://blog.seq.kr/tags/nodejs/"/>
    
      <category term="mysql" scheme="https://blog.seq.kr/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>사용빈도 높은 상태 코드</title>
    <link href="https://blog.seq.kr/2018/11/16/http/restful-status-code/"/>
    <id>https://blog.seq.kr/2018/11/16/http/restful-status-code/</id>
    <published>2018-11-16T13:38:12.000Z</published>
    <updated>2018-11-19T12:09:15.000Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>304 는 넣지 않았습니다. <a href="http://www.restapitutorial.com/httpstatuscodes.html" target="_blank" rel="noopener">참고링크</a></p></blockquote><h3 id="코드-상태별-설명"><a href="#코드-상태별-설명" class="headerlink" title="코드 상태별 설명"></a>코드 상태별 설명</h3><h4 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h4><ul><li>성공 상태를 나타내는 가장 일반적인 코드</li></ul><h4 id="201-Created"><a href="#201-Created" class="headerlink" title="201 Created"></a>201 Created</h4><ul><li>POST 혹은 PUT 요청이 성공하였을 때</li></ul><h4 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h4><ul><li>반환값이 없는 요청이 성공했을 때 (반환시 데이터 본문이 없어야 하므로 delete 시 사용)</li></ul><h4 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h4><ul><li>누락된 데이터, 잘못된 데이터(유효성)의 접근 시</li></ul><h4 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h4><ul><li>미 인증 혹은 인증 만료로 인한 에러 코드</li></ul><h4 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h4><ul><li>유효(권한 등)하지 않는 페이지의 접근 혹은 액션</li></ul><h4 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h4><ul><li>요청한 리소스가 없거나 보안상 401, 403 을 대체</li></ul><h4 id="409-Conflict"><a href="#409-Conflict" class="headerlink" title="409 Conflict"></a>409 Conflict</h4><ul><li>요청의 병합(동시작업)으로 인해 요청을 수행할 수 없을시</li></ul><h4 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h4><ul><li>서버측의 에러로 인한 일반적인 반환 코드(보안상의 이유로 사용자에게 에러 코드는 간략화 한다.)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;&lt;blockquote&gt;&lt;p&gt;304 는 넣지 않았습니다. &lt;a href=&quot;http://www.restapitutorial.com/httpstatuscodes.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;참고링크&lt;/a&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="Http" scheme="https://blog.seq.kr/categories/Http/"/>
    
    
      <category term="http" scheme="https://blog.seq.kr/tags/http/"/>
    
      <category term="status" scheme="https://blog.seq.kr/tags/status/"/>
    
  </entry>
  
  <entry>
    <title>http 응답코드 로드맵</title>
    <link href="https://blog.seq.kr/2018/11/16/http/http-response-code-roadmap/"/>
    <id>https://blog.seq.kr/2018/11/16/http/http-response-code-roadmap/</id>
    <published>2018-11-16T13:20:56.000Z</published>
    <updated>2018-11-20T10:43:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/http/http-response-code-roadmap.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/assets/http/http-response-code-roadmap.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="Http" scheme="https://blog.seq.kr/categories/Http/"/>
    
    
      <category term="http" scheme="https://blog.seq.kr/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>nodejs dockerlize - package.json 을 앞에 놓는이유</title>
    <link href="https://blog.seq.kr/2018/11/16/docker/dockerlize-nodejs/"/>
    <id>https://blog.seq.kr/2018/11/16/docker/dockerlize-nodejs/</id>
    <published>2018-11-16T07:37:36.000Z</published>
    <updated>2018-11-25T11:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h3><p>이유가 여러가지만 nodejs 앱을 dockerlize할 때 보통 package.json을 소스 복사전에 따로 복사해서 의존성을 install 한다.<br><div class="note info"><p><a href="https://nodejs.org/ko/docs/guides/nodejs-docker-webapp/" target="_blank" rel="noopener">https://nodejs.org/ko/docs/guides/nodejs-docker-webapp/</a><br><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank" rel="noopener">https://docs.docker.com/develop/develop-images/dockerfile_best-practices/</a></p></div></p><p>그냥 통으로 현재 디렉토리(어플리케이션 소스등을) 복사해서 install 해도 될텐데 왜 그럴까?</p><ol><li>Dockerfile 에 기술되어있는 순서대로 각 명령별로 레이어를 생성한다. (해당 레이어 생성시 레이어작업 결과물은 최종 이미지의 용량과 관계가 있다.)</li><li>일반적으로 package.json 을 활용하여 Dockerfile 안에서 의존성을 설치하게 된다.</li><li>그런데 만약 변경 소지가 많은 앱 소스 COPY 와 동일 선상혹은 그 이후에 의존성 설치 작업을 하게 되면 매번 소스가 변경 될때 마다 의존성 설치도 계속 하게 된다. (docker 이미지 생성시 레이어 기법을 이용한다.)</li><li>고로 변경 소지가 낮은 package.json 같은 경우 앱 소스 COPY 보다 상위에 두어 docker 의 레이어 캐싱을 활용하게 된다.</li></ol><p>이는 모든 어플리케이션 dockerlize 시에 고려되어야 하는 사항이고 docker image 생성 명령어 기술 시 <strong>최대한 수정 빈도가 낮은것을 수정빈도가 높은것보다 앞에 두는 형식</strong>으로 dockerfile 을 작성해야한다.<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM node:alpine</span><br><span class="line"></span><br><span class="line">WORKDIR /usr/app</span><br><span class="line"></span><br><span class="line">COPY package.json .</span><br><span class="line">RUN npm install --quiet</span><br><span class="line"></span><br><span class="line">COPY . .</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;why&quot;&gt;&lt;a href=&quot;#why&quot; class=&quot;headerlink&quot; title=&quot;why?&quot;&gt;&lt;/a&gt;why?&lt;/h3&gt;&lt;p&gt;이유가 여러가지만 nodejs 앱을 dockerlize할 때 보통 package.json을 소스 복사전에 따로 복사
      
    
    </summary>
    
      <category term="Docker" scheme="https://blog.seq.kr/categories/Docker/"/>
    
    
      <category term="docker" scheme="https://blog.seq.kr/tags/docker/"/>
    
      <category term="nodejs" scheme="https://blog.seq.kr/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>linux timezone 변경하기</title>
    <link href="https://blog.seq.kr/2018/11/16/linux/timezone-change/"/>
    <id>https://blog.seq.kr/2018/11/16/linux/timezone-change/</id>
    <published>2018-11-15T15:00:00.000Z</published>
    <updated>2018-11-25T11:38:08.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>보통 파일을 복사하는 형식으로 timezone을 변경하고 있는데 찾아보니 명령어로 간편하게 변경하는 방법이 있습니다.<br>아래방법은 재부팅되어도 유효한 timezone변경입니다.<br>ubuntu &lt;= 14.04 에서 테스트되었습니다.</p><div class="note info"><p><a href="https://access.redhat.com/documentation/ja-jp/red_hat_enterprise_linux/7/html-single/system_administrators_guide/index#sect-Configuring_the_Date_and_Time-timedatectl" target="_blank" rel="noopener">redhat 문서</a></p></div><h4 id="현재-timezone-정보-확인"><a href="#현재-timezone-정보-확인" class="headerlink" title="현재 timezone 정보 확인"></a>현재 timezone 정보 확인</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># timedatectl status</span></span><br></pre></td></tr></table></figure><h4 id="사용-가능한-timezone-확인"><a href="#사용-가능한-timezone-확인" class="headerlink" title="사용 가능한 timezone 확인"></a>사용 가능한 timezone 확인</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># timedatectl list-timezones</span></span><br></pre></td></tr></table></figure><h4 id="KST로-timezone-변경"><a href="#KST로-timezone-변경" class="headerlink" title="KST로 timezone 변경"></a>KST로 timezone 변경</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># timedatectl set-timezone Asia/Seoul</span></span><br></pre></td></tr></table></figure><h4 id="UTC-timezone-으로-변경"><a href="#UTC-timezone-으로-변경" class="headerlink" title="UTC timezone 으로 변경"></a>UTC timezone 으로 변경</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># timedatectl set-timezone UTC</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;&lt;p&gt;보통 파일을 복사하는 형식으로 timezone을 변경하고 있는데 찾아보니 명령어로 간편하게 변경하는 방법이 있습니다.&lt;br&gt;아래방법은 재부팅되어도 유효한 timezone변경입니다.&lt;br&gt;ubuntu &amp;lt;= 14.04 에서 테스트되었습니
      
    
    </summary>
    
      <category term="Linux" scheme="https://blog.seq.kr/categories/Linux/"/>
    
    
      <category term="linux" scheme="https://blog.seq.kr/tags/linux/"/>
    
      <category term="timezone" scheme="https://blog.seq.kr/tags/timezone/"/>
    
  </entry>
  
  <entry>
    <title>docker compose 최신 이미지 받고 앱 재생성</title>
    <link href="https://blog.seq.kr/2018/11/10/docker/pull-image-deploy/"/>
    <id>https://blog.seq.kr/2018/11/10/docker/pull-image-deploy/</id>
    <published>2018-11-09T15:00:00.000Z</published>
    <updated>2018-11-25T11:45:32.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note primary"><p>docker app 이 구동중이라도 상관 없습니다.</p></div><h4 id="구동중인-root-디렉토리-이동"><a href="#구동중인-root-디렉토리-이동" class="headerlink" title="구동중인 root 디렉토리 이동"></a>구동중인 root 디렉토리 이동</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> some-directory</span><br></pre></td></tr></table></figure><h4 id="최신-이미지-pull-받기"><a href="#최신-이미지-pull-받기" class="headerlink" title="최신 이미지 pull 받기"></a>최신 이미지 pull 받기</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker-compose pull</span><br></pre></td></tr></table></figure><h4 id="최신-이미지로-서비스-재-생성"><a href="#최신-이미지로-서비스-재-생성" class="headerlink" title="최신 이미지로 서비스 재 생성"></a>최신 이미지로 서비스 재 생성</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker-compose up -d</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;docker app 이 구동중이라도 상관 없습니다.&lt;/p&gt;&lt;/div&gt;&lt;h4 id=&quot;구동중인-root-디렉토리-이동&quot;&gt;&lt;a href=&quot;#구동중인-root-디렉토리-이동&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Docker" scheme="https://blog.seq.kr/categories/Docker/"/>
    
    
      <category term="docker" scheme="https://blog.seq.kr/tags/docker/"/>
    
      <category term="docker-compose" scheme="https://blog.seq.kr/tags/docker-compose/"/>
    
  </entry>
  
  <entry>
    <title>chmod 퍼미션</title>
    <link href="https://blog.seq.kr/2018/09/17/linux/chmod-permission-table/"/>
    <id>https://blog.seq.kr/2018/09/17/linux/chmod-permission-table/</id>
    <published>2018-09-16T15:00:00.000Z</published>
    <updated>2018-11-25T11:37:51.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="note info"><p><a href="https://en.wikipedia.org/wiki/Chmod" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Chmod</a></p></div><table><thead><tr><th>#</th><th>Permisstion</th><th>rwx</th><th>Binary</th></tr></thead><tbody><tr><td>7</td><td>read, write and execute</td><td>rwx</td><td>111</td></tr><tr><td>6</td><td>read and write</td><td>rw-</td><td>110</td></tr><tr><td>5</td><td>read and execute</td><td>r-x</td><td>101</td></tr><tr><td>4</td><td>read only</td><td>r–</td><td>100</td></tr><tr><td>3</td><td>write and execute</td><td>-wx</td><td>011</td></tr><tr><td>2</td><td>write only</td><td>-w-</td><td>010</td></tr><tr><td>1</td><td>execute only</td><td>–x</td><td>001</td></tr><tr><td>0</td><td>none</td><td>—</td><td>000</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Chmod&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://en.wikipedia.org/wiki/Chm
      
    
    </summary>
    
      <category term="Linux" scheme="https://blog.seq.kr/categories/Linux/"/>
    
    
      <category term="linux" scheme="https://blog.seq.kr/tags/linux/"/>
    
      <category term="chmod" scheme="https://blog.seq.kr/tags/chmod/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 이상(Firewalld) 방화벽 설정 방법</title>
    <link href="https://blog.seq.kr/2018/09/04/linux/centos7-firewalld-config/"/>
    <id>https://blog.seq.kr/2018/09/04/linux/centos7-firewalld-config/</id>
    <published>2018-09-03T15:00:00.000Z</published>
    <updated>2018-11-25T11:37:07.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.firewalld.org/documentation/" target="_blank" rel="noopener">공식 메뉴얼 제공 사이트입니다.</a></p><p>Centos 7 으로 넘어오면서 기본 방화벽 설정 하는 방법이 변경되었습니다. 정확히는 RHEL 7 이상부터<br>개인 적으로 기존 텍스트로 기술하는게 더 편한것 같네요. 요즘에야 클라우드 쪽에선 방화벽을 지원하니 특별한 경우가 아니고서야 리눅스에서 방화벽 설정할일이 덜하긴 하겠지만요!<br><div class="note info"><p>permanent 옵션이 붙으면 영구적으로 설정된다는 뜻입니다.</p></div></p><h4 id="현재-활성화된-존과-인터페이스-보기"><a href="#현재-활성화된-존과-인터페이스-보기" class="headerlink" title="현재 활성화된 존과 인터페이스 보기"></a>현재 활성화된 존과 인터페이스 보기</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firewall-cmd --get-active-zones</span></span><br></pre></td></tr></table></figure><h4 id="존-상태보기"><a href="#존-상태보기" class="headerlink" title="존 상태보기"></a>존 상태보기</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firewall-cmd --zone=&#123;존명&#125; --list-all</span></span><br></pre></td></tr></table></figure><h4 id="이더넷에-정책-할당하기-eth0-번-이더넷에-internal-존-적용혹은-삭제-하는-방법"><a href="#이더넷에-정책-할당하기-eth0-번-이더넷에-internal-존-적용혹은-삭제-하는-방법" class="headerlink" title="이더넷에 정책 할당하기(eth0 번 이더넷에 internal 존 적용혹은 삭제 하는 방법)"></a>이더넷에 정책 할당하기(eth0 번 이더넷에 internal 존 적용혹은 삭제 하는 방법)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firewall-cmd --permanent --zone=internal --add-interface=eth0</span></span><br><span class="line"><span class="comment"># firewall-cmd --permanent --zone=internal --remove-interface=eth0</span></span><br></pre></td></tr></table></figure><h4 id="현재-존에-개방된-포트"><a href="#현재-존에-개방된-포트" class="headerlink" title="현재 존에 개방된 포트"></a>현재 존에 개방된 포트</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firewall-cmd --zone=&#123;존명&#125; --list-ports</span></span><br></pre></td></tr></table></figure><h4 id="현재-존에-개방된-서비스-well-know-에-해당"><a href="#현재-존에-개방된-서비스-well-know-에-해당" class="headerlink" title="현재 존에 개방된 서비스(well-know 에 해당)"></a>현재 존에 개방된 서비스(well-know 에 해당)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firewall-cmd --zone=&#123;존명&#125; --list-services</span></span><br></pre></td></tr></table></figure><h4 id="현재-존에-개방된-아이피"><a href="#현재-존에-개방된-아이피" class="headerlink" title="현재 존에 개방된 아이피"></a>현재 존에 개방된 아이피</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firewall-cmd --zone=&#123;존명&#125; --list-sources</span></span><br></pre></td></tr></table></figure><h4 id="존에-포트추가하기"><a href="#존에-포트추가하기" class="headerlink" title="존에 포트추가하기"></a>존에 포트추가하기</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firewall-cmd --permanent --zone=&#123;존명&#125; --add-port=&#123;포트번호&#125;/&#123;tcp 혹은 udp&#125;</span></span><br></pre></td></tr></table></figure><h4 id="존에-포트-범위로-추가하기-0-65535-번-추가"><a href="#존에-포트-범위로-추가하기-0-65535-번-추가" class="headerlink" title="존에 포트 범위로 추가하기(0~65535 번 추가)"></a>존에 포트 범위로 추가하기(0~65535 번 추가)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firewall-cmd --permanent --zone=&#123;존명&#125; --add-port=0-65535/&#123;tcp 혹은 udp&#125;</span></span><br></pre></td></tr></table></figure><h4 id="존에-추가된-포트-삭제하기"><a href="#존에-추가된-포트-삭제하기" class="headerlink" title="존에 추가된 포트 삭제하기"></a>존에 추가된 포트 삭제하기</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firewall-cmd --zone=&#123;존명&#125; --remove-port=&#123;포트번호&#125;/&#123;tcp 혹은 udp&#125;</span></span><br></pre></td></tr></table></figure><h4 id="firewalld-리로드"><a href="#firewalld-리로드" class="headerlink" title="firewalld 리로드"></a>firewalld 리로드</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firewall-cmd --reload</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.firewalld.org/documentation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;공식 메뉴얼 제공 사이트입니다.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Centos 7 으로 넘어오면서 기본 방화벽 설정 
      
    
    </summary>
    
      <category term="Linux" scheme="https://blog.seq.kr/categories/Linux/"/>
    
    
      <category term="linux" scheme="https://blog.seq.kr/tags/linux/"/>
    
      <category term="firewalld" scheme="https://blog.seq.kr/tags/firewalld/"/>
    
  </entry>
  
  <entry>
    <title>minio 설치(docker compose install)</title>
    <link href="https://blog.seq.kr/2018/09/02/open-source/introduce-minio/"/>
    <id>https://blog.seq.kr/2018/09/02/open-source/introduce-minio/</id>
    <published>2018-09-02T14:42:53.000Z</published>
    <updated>2018-09-02T14:42:53.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="note info"><p>Docker, NAS, LocalDrive등의 다양한 환경에 따른 설치법이 공식 홈페이지 존재합니다.<br>여기선 docker compose를 이용한 Standalone설치 법입니다.<br>공식사이트: <a href="https://www.minio.io/" target="_blank" rel="noopener">https://www.minio.io/</a></p></div><h4 id="설치-전"><a href="#설치-전" class="headerlink" title="설치 전"></a>설치 전</h4><ul><li>aws의 s3와 같은 open source가 없나 찾아보니 괜찮은게 있어서 소개해드립니다.</li><li>minio에서 제공하는 sdk같은 경우 설정 정보면 변경하면 s3로 바로 전환할 수 있게끔 인터페이스를 제공하고 있습니다.<ul><li>본문은 s3가 아니고 minio 를 이용하여 object storage를 설치하는 내용입니다.</li></ul></li></ul><h4 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h4><h5 id="docker-compose-yml-작성"><a href="#docker-compose-yml-작성" class="headerlink" title="docker-compose.yml 작성"></a>docker-compose.yml 작성</h5><figure class="highlight yml"><figcaption><span>docker-compose.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr"> minio:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">minio/minio</span></span><br><span class="line"><span class="attr">  restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="bullet">   -</span> <span class="string">/home/minio-data:/export</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="bullet">   -</span> <span class="string">"9000:9000"</span></span><br><span class="line"><span class="attr">  environment:</span></span><br><span class="line"><span class="attr">   MINIO_ACCESS_KEY:</span> <span class="string">login</span></span><br><span class="line"><span class="attr">   MINIO_SECRET_KEY:</span> <span class="string">password</span></span><br><span class="line"><span class="attr">  command:</span> <span class="string">server</span> <span class="string">/export</span></span><br></pre></td></tr></table></figure><ul><li><code>volumes</code><ul><li>데이터가 저장 될 위치입니다. “:” 기준으로 왼쪽 path 에 실제 host에 저장 될 위치를 지정합니다. ex) /home/minio-data</li></ul></li><li><code>enviroment</code><ul><li><code>MINIO_ACCESS_KEY</code> - 임의의 access key 를 정의합니다. (아이디)</li><li><code>MINIO_SECRET_KEY</code> - 임의의 secret key 를 정의합니다. (패스워드)</li></ul></li></ul><h5 id="minio-docker-구동"><a href="#minio-docker-구동" class="headerlink" title="minio docker 구동"></a>minio docker 구동</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo docker-compose up -d</span></span><br></pre></td></tr></table></figure><h5 id="minio-웹-UI-접근"><a href="#minio-웹-UI-접근" class="headerlink" title="minio 웹 UI 접근"></a>minio 웹 UI 접근</h5><ol><li>http://주소:9000 접근합니다.</li><li>위에서 정의한 access key, secret key로 로그인합니다.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;Docker, NAS, LocalDrive등의 다양한 환경에 따른 설치법이 공식 홈페이지 존재합니다.&lt;br&gt;여기선 docker compose를 이용한 Standalone설치 법입니다.&lt;br&gt;공식사이
      
    
    </summary>
    
      <category term="Open source" scheme="https://blog.seq.kr/categories/Open-source/"/>
    
    
      <category term="minio" scheme="https://blog.seq.kr/tags/minio/"/>
    
      <category term="open source" scheme="https://blog.seq.kr/tags/open-source/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu 16.04 swap 메모리 추가하기</title>
    <link href="https://blog.seq.kr/2018/09/02/linux/ubuntu16.04-swap-config/"/>
    <id>https://blog.seq.kr/2018/09/02/linux/ubuntu16.04-swap-config/</id>
    <published>2018-09-01T15:00:00.000Z</published>
    <updated>2018-11-25T11:38:30.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="설정-변경-전"><a href="#설정-변경-전" class="headerlink" title="설정 변경 전"></a>설정 변경 전</h4><ul><li>물리적 메모리의 * 2 배 정도로 추가하면 무난하다.<ul><li>상황에 따라 메모리가 많다면 1~1.5 배 고려 ( 구동되는 서비스들의 상황에 맞게 줄이 거나 늘리거나 ) <a href="https://www.redhat.com/en/blog/do-we-really-need-swap-modern-systems" target="_blank" rel="noopener">(<strong>참고 문서</strong>)</a></li><li>swappiness 설정도 필요하면 하자.</li></ul></li></ul><h4 id="2GB의-swap-메모리-추가"><a href="#2GB의-swap-메모리-추가" class="headerlink" title="2GB의 swap 메모리 추가"></a>2GB의 swap 메모리 추가</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo fallocate -l 2G /swapfile</span><br><span class="line">$ sudo chmod 600 /swapfile</span><br><span class="line">$ sudo mkswap /swapfile</span><br><span class="line">$ sudo swapon /swapfile</span><br></pre></td></tr></table></figure><h4 id="swap-할당-확인"><a href="#swap-할당-확인" class="headerlink" title="swap 할당 확인"></a>swap 할당 확인</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ free -m</span><br></pre></td></tr></table></figure><p><hr></p><h4 id="재-부팅시에도-자동-할당"><a href="#재-부팅시에도-자동-할당" class="headerlink" title="재 부팅시에도 자동 할당"></a>재 부팅시에도 자동 할당</h4><h5 id="기존-파일-백업"><a href="#기존-파일-백업" class="headerlink" title="기존 파일 백업"></a>기존 파일 백업</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp /etc/fstab /etc/fstab.bak</span><br></pre></td></tr></table></figure><h5 id="설정-추가"><a href="#설정-추가" class="headerlink" title="설정 추가"></a>설정 추가</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'/swapfile none swap sw 0 0'</span> | sudo tee -a /etc/fstab</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;설정-변경-전&quot;&gt;&lt;a href=&quot;#설정-변경-전&quot; class=&quot;headerlink&quot; title=&quot;설정 변경 전&quot;&gt;&lt;/a&gt;설정 변경 전&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;물리적 메모리의 * 2 배 정도로 추가하면 무난하다.&lt;ul&gt;&lt;li&gt;상황에 따라 메
      
    
    </summary>
    
      <category term="Linux" scheme="https://blog.seq.kr/categories/Linux/"/>
    
    
      <category term="linux" scheme="https://blog.seq.kr/tags/linux/"/>
    
      <category term="ubuntu" scheme="https://blog.seq.kr/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu docker compose 설치</title>
    <link href="https://blog.seq.kr/2018/09/02/docker/compose-install-ubuntu/"/>
    <id>https://blog.seq.kr/2018/09/02/docker/compose-install-ubuntu/</id>
    <published>2018-09-01T15:00:00.000Z</published>
    <updated>2018-11-25T11:47:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>아래 방법은 공식사이트에서 가져온 내용입니다.<br>개인적으로 root 설치하기를 권장합니다.<br><div class="note info"><p><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">docker install link</a><br><a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">docker-compose install link</a></p></div></p><h4 id="docker-설치"><a href="#docker-설치" class="headerlink" title="docker 설치"></a>docker 설치</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"> </span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br><span class="line"> </span><br><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"> </span><br><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br><span class="line"> </span><br><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="variable">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable"</span></span><br><span class="line"> </span><br><span class="line">$ sudo apt-get update</span><br><span class="line"> </span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure><h4 id="docker-설치-테스트"><a href="#docker-설치-테스트" class="headerlink" title="docker 설치 테스트"></a>docker 설치 테스트</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br><span class="line"></span><br><span class="line">$ sudo docker ps -a</span><br><span class="line">실행 확인</span><br><span class="line"></span><br><span class="line">$ sudo docker rm &#123;위에서 확인한 CONTAINER ID&#125;</span><br><span class="line"></span><br><span class="line">$ sudo docker rmi hello-world</span><br></pre></td></tr></table></figure><h4 id="docker-compose-설치"><a href="#docker-compose-설치" class="headerlink" title="docker compose 설치"></a>docker compose 설치</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https://github.com/docker/compose/releases/download/1.21.0/docker-compose-$(uname -s)-$(uname -m) -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line">$ sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line">$ sudo docker-compose --version</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;아래 방법은 공식사이트에서 가져온 내용입니다.&lt;br&gt;개인적으로 root 설치하기를 권장합니다.&lt;br&gt;&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/install/linux/docker-c
      
    
    </summary>
    
      <category term="Docker" scheme="https://blog.seq.kr/categories/Docker/"/>
    
    
      <category term="docker" scheme="https://blog.seq.kr/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>NVM 으로 node 버전 쉽게 관리하기</title>
    <link href="https://blog.seq.kr/2018/05/19/nodejs/node-version-manager-usage/"/>
    <id>https://blog.seq.kr/2018/05/19/nodejs/node-version-manager-usage/</id>
    <published>2018-05-18T15:00:00.000Z</published>
    <updated>2018-11-25T11:40:02.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="note info"><p>최신 설치법은 아래 링크 참고해주세요.<br><a href="https://github.com/creationix/nvm#install-script" target="_blank" rel="noopener">Github nvm 공식 repository</a><br>아래 글은 우분투 16.04 기준입니다.</p></div><h4 id="nvm-설치"><a href="#nvm-설치" class="headerlink" title="nvm 설치"></a>nvm 설치</h4><h5 id="nvm-설치-1"><a href="#nvm-설치-1" class="headerlink" title="nvm 설치"></a>nvm 설치</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> view .bashrc</span></span><br><span class="line"></span><br><span class="line">하단에 아래와 같은 profile이 추가 되었는지 확인 후 (우분투 기준입니다.) 없다면 수동 추가바랍니다.</span><br><span class="line">보통은 자동 추가가 됩니다.</span><br></pre></td></tr></table></figure><h5 id="자동-스크립트-추가-확인"><a href="#자동-스크립트-추가-확인" class="headerlink" title="자동 스크립트 추가 확인"></a>자동 스크립트 추가 확인</h5><figure class="highlight bash"><figcaption><span>.bashrc 나 .bash_profile 하단 내용</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span>  <span class="comment"># This loads nvm</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/bash_completion"</span> ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/bash_completion"</span>  <span class="comment"># This loads nvm bash_completion</span></span><br></pre></td></tr></table></figure><h5 id="설치-path-업데이트"><a href="#설치-path-업데이트" class="headerlink" title="설치 path 업데이트"></a>설치 path 업데이트</h5><figure class="highlight shell"><figcaption><span>설치 후 바로 사용할 경우 profile 을 읽어주어야 합니다.(재 로그인 시 불 필요)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> ~/.bashrc 또는 <span class="built_in">source</span> ~/.bash_profile</span></span><br></pre></td></tr></table></figure><h5 id="설치-확인"><a href="#설치-확인" class="headerlink" title="설치 확인"></a>설치 확인</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm --version</span><br></pre></td></tr></table></figure><p><br></p><h4 id="최신-LTS-node-설치"><a href="#최신-LTS-node-설치" class="headerlink" title="최신 LTS node 설치"></a>최신 LTS node 설치</h4><h5 id="설치-가능한-LTS-버전-확인"><a href="#설치-가능한-LTS-버전-확인" class="headerlink" title="설치 가능한 LTS 버전 확인"></a>설치 가능한 LTS 버전 확인</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ nvm ls-remote --lts</span><br><span class="line">         v4.2.0   (LTS: Argon)</span><br><span class="line">         v4.2.1   (LTS: Argon)</span><br><span class="line">         v4.2.2   (LTS: Argon)</span><br><span class="line">        ... 중략</span><br><span class="line">        v8.11.0   (LTS: Carbon)</span><br><span class="line">        v8.11.1   (LTS: Carbon)</span><br><span class="line">        v8.11.2   (Latest LTS: Carbon)</span><br></pre></td></tr></table></figure><h5 id="선택한-LTS-node-설치하기"><a href="#선택한-LTS-node-설치하기" class="headerlink" title="선택한 LTS node 설치하기"></a>선택한 LTS node 설치하기</h5><figure class="highlight bash"><figcaption><span>설치 버전은 자신에 맞게 변경하시면됩니다. 여기선 v8.11.2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install v8.11.2</span><br><span class="line">Downloading and installing node v8.11.2...</span><br><span class="line">Downloading https://nodejs.org/dist/v8.11.2/node-v8.11.2-linux-x64.tar.xz...</span><br><span class="line"><span class="comment">######################################################################## 100.0%</span></span><br><span class="line">Computing checksum with sha256sum</span><br><span class="line">Checksums matched!</span><br><span class="line">Now using node v8.11.2 (npm v5.6.0)</span><br><span class="line">Creating default <span class="built_in">alias</span>: default -&gt; v8.11.2</span><br></pre></td></tr></table></figure><h5 id="설치-확인-1"><a href="#설치-확인-1" class="headerlink" title="설치 확인"></a>설치 확인</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ nvm list</span><br><span class="line">-&gt;      v8.11.2</span><br><span class="line">default -&gt; v8.11.2</span><br><span class="line">node -&gt; stable (-&gt; v8.11.2) (default)</span><br><span class="line">stable -&gt; 8.11 (-&gt; v8.11.2) (default)</span><br><span class="line">iojs -&gt; N/A (default)</span><br><span class="line">lts/* -&gt; lts/carbon (-&gt; v8.11.2)</span><br><span class="line">lts/argon -&gt; v4.9.1 (-&gt; N/A)</span><br><span class="line">lts/boron -&gt; v6.14.2 (-&gt; N/A)</span><br><span class="line">lts/carbon -&gt; v8.11.2</span><br><span class="line"></span><br><span class="line">$ node -v</span><br><span class="line">v8.11.2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;최신 설치법은 아래 링크 참고해주세요.&lt;br&gt;&lt;a href=&quot;https://github.com/creationix/nvm#install-script&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
      <category term="Nodejs" scheme="https://blog.seq.kr/categories/Nodejs/"/>
    
    
      <category term="nodejs" scheme="https://blog.seq.kr/tags/nodejs/"/>
    
      <category term="nvm" scheme="https://blog.seq.kr/tags/nvm/"/>
    
  </entry>
  
  <entry>
    <title>Docker로 빠르게 mariadb, redis 서버 구동시키기</title>
    <link href="https://blog.seq.kr/2018/05/07/docker/docker-redis-mariadb-start/"/>
    <id>https://blog.seq.kr/2018/05/07/docker/docker-redis-mariadb-start/</id>
    <published>2018-05-06T15:00:00.000Z</published>
    <updated>2018-11-25T11:46:14.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note primary"><p>중 괄호를 포함한 부분은 각자에 맡게 변경하시면 됩니다.<br>호스트 OS 에서 127.0.0.1로 접속하면 됩니다.</p></div><h4 id="Mariadb5-버전대-사용-utf-8"><a href="#Mariadb5-버전대-사용-utf-8" class="headerlink" title="Mariadb5 버전대 사용(utf-8)"></a>Mariadb5 버전대 사용(utf-8)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --name mariadb5 -p 127.0.0.1:3306:3306 \</span><br><span class="line">-v &#123;호스트에 위치할 데이타 디렉토리&#125;:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=&#123;root비밀번호&#125; \</span><br><span class="line">-d mariadb:5.5 \</span><br><span class="line">--character-set-server=utf8 \</span><br><span class="line">--collation-server=utf8_general_ci</span><br></pre></td></tr></table></figure><h4 id="redis3-2-버전대-사용"><a href="#redis3-2-버전대-사용" class="headerlink" title="redis3.2 버전대 사용"></a>redis3.2 버전대 사용</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --name redis -p 127.0.0.1:6379:6379 -d redis:3.2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;중 괄호를 포함한 부분은 각자에 맡게 변경하시면 됩니다.&lt;br&gt;호스트 OS 에서 127.0.0.1로 접속하면 됩니다.&lt;/p&gt;&lt;/div&gt;&lt;h4 id=&quot;Mariadb5-버전대-사용-utf-8&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Docker" scheme="https://blog.seq.kr/categories/Docker/"/>
    
    
      <category term="docker" scheme="https://blog.seq.kr/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>자바스크립트에서 false 반환 하는 경우</title>
    <link href="https://blog.seq.kr/2018/04/10/javascript/when-return-false/"/>
    <id>https://blog.seq.kr/2018/04/10/javascript/when-return-false/</id>
    <published>2018-04-10T13:38:12.000Z</published>
    <updated>2018-11-20T10:43:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>특정 변수의 값의 true, false 여부를 반환할시 아래와 같은 조건은 묵시적으로 false를 반환한다.<br><figure class="highlight javascript"><figcaption><span>아래와 같은 코드 사용 시</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( test ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"true"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"false"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>null 일 때</li><li>undefined 일 때</li><li>NaN 일 때</li><li>공백 일 때</li><li>숫자 0 (‘0’ 은 true)</li><li>false</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;특정 변수의 값의 true, false 여부를 반환할시 아래와 같은 조건은 묵시적으로 false를 반환한다.&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;figcaption&gt;&lt;span&gt;아래와 같은 코드 사용 시&lt;/sp
      
    
    </summary>
    
      <category term="Javascript" scheme="https://blog.seq.kr/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="https://blog.seq.kr/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>모든 이미지 컨테이너 일괄 삭제</title>
    <link href="https://blog.seq.kr/2018/04/10/docker/container-image-remove/"/>
    <id>https://blog.seq.kr/2018/04/10/docker/container-image-remove/</id>
    <published>2018-04-09T15:00:00.000Z</published>
    <updated>2018-11-25T11:46:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="모든-컨테이너-삭제"><a href="#모든-컨테이너-삭제" class="headerlink" title="모든 컨테이너 삭제"></a>모든 컨테이너 삭제</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure><h3 id="모든-이미지-삭제"><a href="#모든-이미지-삭제" class="headerlink" title="모든 이미지 삭제"></a>모든 이미지 삭제</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;모든-컨테이너-삭제&quot;&gt;&lt;a href=&quot;#모든-컨테이너-삭제&quot; class=&quot;headerlink&quot; title=&quot;모든 컨테이너 삭제&quot;&gt;&lt;/a&gt;모든 컨테이너 삭제&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
      <category term="Docker" scheme="https://blog.seq.kr/categories/Docker/"/>
    
    
      <category term="linux" scheme="https://blog.seq.kr/tags/linux/"/>
    
      <category term="chmod" scheme="https://blog.seq.kr/tags/chmod/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs-pm2 사용해보기</title>
    <link href="https://blog.seq.kr/2018/04/10/nodejs/nodejs-pm2-usage/"/>
    <id>https://blog.seq.kr/2018/04/10/nodejs/nodejs-pm2-usage/</id>
    <published>2018-04-09T15:00:00.000Z</published>
    <updated>2018-11-25T11:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>노드 앱을 구동하기 위해서 다양한 도구들을 사용하지만 저는 pm2를 사용합니다. 개발뿐만 아니라 실제 production에서도 사용하기 좋은 툴입니다. 매우 다양한 옵션도 지원하구요!<br>pm2를 사용하여 쉽게 앱 관리&amp;watch&amp;클러스터 모드등을 사용할수 있습니다.</p><h4 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h4><h5 id="pm2-global-로-설치"><a href="#pm2-global-로-설치" class="headerlink" title="pm2 global 로 설치"></a>pm2 global 로 설치</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install pm2 -g</span><br></pre></td></tr></table></figure><h5 id="pm2정상-설치-확인"><a href="#pm2정상-설치-확인" class="headerlink" title="pm2정상 설치 확인"></a>pm2정상 설치 확인</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 -v</span><br></pre></td></tr></table></figure><h4 id="사용법"><a href="#사용법" class="headerlink" title="사용법"></a>사용법</h4><h5 id="기본-express-템플릿-생성"><a href="#기본-express-템플릿-생성" class="headerlink" title="기본 express 템플릿 생성"></a>기본 express 템플릿 생성</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir <span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="built_in">test</span></span><br><span class="line">$ express --view=ejs</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h5 id="pm2-이용하여-앱-구동"><a href="#pm2-이용하여-앱-구동" class="headerlink" title="pm2 이용하여 앱 구동"></a>pm2 이용하여 앱 구동</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 start bin/www --name=pm2-test</span><br></pre></td></tr></table></figure><h5 id="monit-명령어"><a href="#monit-명령어" class="headerlink" title="monit 명령어"></a>monit 명령어</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 monit</span><br></pre></td></tr></table></figure><p>위 방법은 아주 간단히 pm2를 이용하여 프로젝트를 구동한 모습입니다. 그럼 <code>ecosystem</code>이란것을 이용하여 좀더 간단히 그리고 옵션도 주어서 구동시켜봅니다.</p><h4 id="ecosystem-템플릿-사용"><a href="#ecosystem-템플릿-사용" class="headerlink" title="ecosystem 템플릿 사용"></a>ecosystem 템플릿 사용</h4><h5 id="ecosystem-config-js-생성"><a href="#ecosystem-config-js-생성" class="headerlink" title="ecosystem.config.js 생성"></a>ecosystem.config.js 생성</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 ecosystem</span><br></pre></td></tr></table></figure><h5 id="내용-삭제-후-아래-내용으로-교체"><a href="#내용-삭제-후-아래-내용으로-교체" class="headerlink" title="내용 삭제 후 아래 내용으로 교체"></a>내용 삭제 후 아래 내용으로 교체</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi ecosystem.config.js</span><br></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>ecosystem.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">apps :</span><br><span class="line">    &#123;</span><br><span class="line">      name      : <span class="string">'pm2-test'</span>,</span><br><span class="line">      script    : <span class="string">'bin/www'</span>,</span><br><span class="line">      watch     : <span class="literal">true</span>,</span><br><span class="line">      ignore_watch : [<span class="string">"logs"</span>],</span><br><span class="line">      exec_mode : <span class="string">"cluster"</span>,</span><br><span class="line">      instances : 0,</span><br><span class="line">      merge_logs : <span class="literal">true</span>,</span><br><span class="line">      log_date_format : <span class="string">"YY-MM-DD HH:mm:ss"</span>,</span><br><span class="line">      error_file : <span class="string">"./logs/err.log"</span>,</span><br><span class="line">      out_file : <span class="string">"./logs/out.log"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note info"><p>이 포스트에 모든 옵션을 넣기엔 약간 무리가 있어보입니다. 위에 적힌 옵션들만 보자면<br><code>name</code> : pm2 에서 관리하는 이름입니다.<br><code>script</code> : 앱을 구동할 경로 입니다. 보통 app.js 나 express 로 만드셨다면 bin/www 가 되겠지요<br><code>watch</code> : 파일이 변경되면 자동으로 재시작 하겠다는 의미입니다. 개발시에 유용합니다.<br><code>ignore_watch</code> : 배열안에 있는 리스트는 watch 대상에서 무시하겠다는 의미입니다. 로그파일이나 데이터 폴더등의 경로 혹은 이름이 될것입니다.<br><code>exec_mode</code> : 클러스터 모드로 구동합니다<br><code>instances</code> : 클러스터로 구동될시 몇개까지 구동할것인지 선택합니다.(0 : cpu갯수)<br><code>merge_logs</code> : 클러스터로 구동할시 로그를 한파일에 기록합니다.<br><code>log_date_format</code> : 로그에 출력될 날짜와 시간값의 형식입니다.<br><code>error_file</code> : 에러 파일 위치<br><code>out_file</code> : 기본 출력 로그 위치</p><p><strong>공식 메뉴얼 : <a href="http://pm2.keymetrics.io/docs/usage/application-declaration/" target="_blank" rel="noopener">http://pm2.keymetrics.io/docs/usage/application-declaration/</a></strong></p></div><h4 id="ecosystem-사용"><a href="#ecosystem-사용" class="headerlink" title="ecosystem 사용"></a>ecosystem 사용</h4><h5 id="기존-pm2-test-삭제"><a href="#기존-pm2-test-삭제" class="headerlink" title="기존 pm2-test 삭제"></a>기존 pm2-test 삭제</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 delete pm2-test</span><br></pre></td></tr></table></figure><h5 id="ecosystem-config-js로-시작"><a href="#ecosystem-config-js로-시작" class="headerlink" title="ecosystem.config.js로 시작"></a>ecosystem.config.js로 시작</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 start ecosystem.config.js</span><br></pre></td></tr></table></figure><h5 id="구동-확인"><a href="#구동-확인" class="headerlink" title="구동 확인"></a>구동 확인</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 list</span><br></pre></td></tr></table></figure><h4 id="네트워크-환경에서의-watch-사용"><a href="#네트워크-환경에서의-watch-사용" class="headerlink" title="네트워크 환경에서의 watch 사용"></a>네트워크 환경에서의 watch 사용</h4><div class="note danger"><p>vagrant같은 가상환경을 사용할시 pm2 에서 watch 옵션을 주고 파일 내용을 변경해도 자동시작이 되지 않을수 있습니다.(네트워크 마운트일 때) 그럴 경우 아래와 같은 옵션을 추가 시켜주세요.<br><code>watch_options : {&quot;usePolling&quot;: true, &quot;interval&quot;:2000, &quot;binaryInterval&quot;:2000}</code><br>제사한 내용은 아래 문서 참고<br><strong><a href="https://github.com/paulmillr/chokidar#api" target="_blank" rel="noopener">https://github.com/paulmillr/chokidar#api</a></strong></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;노드 앱을 구동하기 위해서 다양한 도구들을 사용하지만 저는 pm2를 사용합니다. 개발뿐만 아니라 실제 production에서도 사용하기 좋은 툴입니다. 매우 다양한 옵션도 지원하구요!&lt;br&gt;pm2를 사용하여 쉽게 앱 관리&amp;amp;watch&amp;amp
      
    
    </summary>
    
      <category term="Nodejs" scheme="https://blog.seq.kr/categories/Nodejs/"/>
    
    
      <category term="nodejs" scheme="https://blog.seq.kr/tags/nodejs/"/>
    
      <category term="pm2" scheme="https://blog.seq.kr/tags/pm2/"/>
    
  </entry>
  
</feed>
